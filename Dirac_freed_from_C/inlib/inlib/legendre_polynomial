// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_legendre_polynomial
#define inlib_legendre_polynomial

// from https://en.wikipedia.org/wiki/Legendre_polynomials.

namespace inlib {

template <class UINT,class REAL>
inline void legendre_polynomial(const UINT& a_n,const REAL& a_x,REAL& a_value) {
  if(a_n==0) {a_value = REAL(1);return;}
  if(a_n==1) {a_value = a_x;return;}

  // (n+1)P[n+1](x) = (2n+1)*x*P[n](x) - n*P[n-1](x)
  // n*P[n](x) = (2n-1)*x*P[n-1](x) - (n-1)*P[n-2](x)

  REAL P_n_2;
  legendre_polynomial(0,a_x,P_n_2);
  REAL P_n_1,P_n;

  for(UINT n=2;n<=a_n;n++) {
    legendre_polynomial(n-1,a_x,P_n_1);
    P_n = ((REAL(2)*REAL(n)-REAL(1))*a_x*P_n_1 - (REAL(n)-REAL(1))*P_n_2)/REAL(n);
    P_n_2 = P_n_1;
  }
  a_value = P_n;
}

inline void check_legendre_polynomial() {double value;legendre_polynomial(10,1.0,value);}

}

// from https://en.wikipedia.org/wiki/Associated_Legendre_polynomials.

#include "mathT"   //for factorial.

namespace inlib {

template <class INT,class REAL>
inline bool associated_legendre_polynomial(const INT& a_m,const INT& a_l,const REAL& a_x,REAL& a_value,REAL(*a_sqrt)(const REAL&)) {
  if((a_x<REAL(-1))||(REAL(1)<a_x)) {a_value = REAL(0);return false;}

  if(a_l<0) {
    if(!associated_legendre_polynomial(a_m,-a_l-1,a_x,a_value,a_sqrt)) {a_value = REAL(0);return false;}
    return true;
  }

  if(a_m<0) {
    if((a_l+a_m)<0) {a_value = REAL(0);return true;}
    REAL P_minus_m_l;
    if(!associated_legendre_polynomial(-a_m,a_l,a_x,P_minus_m_l,a_sqrt)) {a_value = REAL(0);return false;}
    REAL l_plus_m_fac;factorial<INT,REAL>(a_l+a_m,l_plus_m_fac);
    REAL l_minus_m_fac;factorial<INT,REAL>(a_l-a_m,l_minus_m_fac);
    REAL minus_power_m;power<REAL,INT>(-1,-a_m,minus_power_m);
    a_value = minus_power_m*P_minus_m_l*l_plus_m_fac/l_minus_m_fac;
    return true;
  }

  if(a_l<a_m) {a_value = REAL(0);return true;}

  // 0 <= m <= l :

  if(a_m==a_l) {
    if(a_l==0) {a_value = REAL(1);return true;}
    REAL P_l_l_1;
    if(!associated_legendre_polynomial(0,0,a_x,P_l_l_1,a_sqrt)) {a_value = REAL(0);return false;}
    REAL _sqrt = a_sqrt(REAL(1)-a_x*a_x);
    REAL P_l_l;
    for(INT l=1;l<=a_l;l++) {
      P_l_l = -(REAL(2)*REAL(l)-REAL(1))*_sqrt*P_l_l_1;
      P_l_l_1 = P_l_l;
    }
    a_value = P_l_l;
    return true;
  }

  if(a_l==(a_m+1)) {
    REAL P_m_m;
    if(!associated_legendre_polynomial(a_m,a_m,a_x,P_m_m,a_sqrt)) {a_value = REAL(0);return false;}
    a_value = a_x*(REAL(2)*REAL(a_m)+REAL(1))*P_m_m;
    return true;
  }

  if(a_m<a_l) { // a_m+2 <= a_l. //descent a_l up to a_m :
    REAL P_m_l_2;
    if(!associated_legendre_polynomial(a_m,a_m,a_x,P_m_l_2,a_sqrt)) {a_value = REAL(0);return false;}
    REAL P_m_l_1,P_m_l;
    for(INT l=a_m+2;l<=a_l;l++) {
      if(!associated_legendre_polynomial(a_m,l-1,a_x,P_m_l_1,a_sqrt)) {a_value = REAL(0);return false;}
      P_m_l = ((REAL(2)*REAL(l)-REAL(1))*a_x*P_m_l_1 - (REAL(l)-REAL(1)+REAL(a_m))*P_m_l_2)/(REAL(l)-REAL(a_m));
      P_m_l_2 = P_m_l_1;
    }
    a_value = P_m_l;
    return true;
  }

  a_value = REAL(0);
  return false;

/* below deals with a_l<a_m which is excluded upper.

  //WARNING : below had not been tested yet.

  REAL _sqrt = a_sqrt(1-a_x*a_x);
  if(a_m==(a_l+1)) {
    REAL P_l_l;
    if(!associated_legendre_polynomial(a_l,a_l,a_x,P_l_l,a_sqrt)) {a_value = REAL(0);return false;}
    REAL P_l_1_l;
    if(!associated_legendre_polynomial(a_l-1,a_l,a_x,P_l_1_l,a_sqrt)) {a_value = REAL(0);return false;}
    a_value = (-REAL(2)*REAL(a_l)*a_x*P_l_l - _sqrt*REAL(2)*REAL(a_l)*P_l_1_l)/_sqrt;
    return true;
  }

  // a_m>a_l // a_m >= a_l+2. //descent a_m up to a_l :
  REAL P_m_2_l;
  if(!associated_legendre_polynomial(a_l,a_l,a_x,P_m_2_l,a_sqrt)) {a_value = REAL(0);return false;}
  REAL P_m_1_l;
  REAL P_m_l;
  for(INT m=a_l+2;m<=a_m;m++) {
    if(!associated_legendre_polynomial(m-1,a_l,a_x,P_m_1_l,a_sqrt)) {a_value = REAL(0);return false;}
    P_m_l = (-REAL(2)*(REAL(m)-REAL(1))*a_x*P_m_1_l - _sqrt*(REAL(a_l)+REAL(m)-REAL(1))*(REAL(a_l)-REAL(m)+REAL(2))*P_m_2_l)/_sqrt;
    P_m_1_2 = P_m_1_l;
  }
  a_value = P_m_l;
  return true;
  */
}

// from https://en.wikipedia.org/wiki/Spherical_harmonics.

template <class INT,class REAL>
inline bool y_l_m(const INT& a_m,const INT& a_l,
                  REAL& a_value,
                  REAL(*a_sqrt)(const REAL&),
                  const REAL& a_pi) {
  if((a_m<-a_l)||(a_l<a_m)) {a_value = REAL(0);return false;}
  REAL l_plus_m_fac;factorial<INT,REAL>(a_l+a_m,l_plus_m_fac);
  REAL l_minus_m_fac;factorial<INT,REAL>(a_l-a_m,l_minus_m_fac);
  REAL factor = (REAL(2)*a_l+REAL(1))*l_minus_m_fac/(REAL(4)*a_pi*l_plus_m_fac);
  a_value = a_sqrt(factor);
  return true;
}

template <class INT,class COMPLEX>
inline bool spherical_harmonic(const INT& a_m,const INT& a_l,
                               const typename COMPLEX::value_type& a_theta,const typename COMPLEX::value_type& a_phi,
                               COMPLEX& a_value,
			       typename COMPLEX::value_type(*a_sqrt)(const typename COMPLEX::value_type&),
			       typename COMPLEX::value_type(*a_sin)(const typename COMPLEX::value_type&),
			       typename COMPLEX::value_type(*a_cos)(const typename COMPLEX::value_type&),
			       const typename COMPLEX::value_type& a_pi) {
  typedef typename COMPLEX::value_type REAL;
  if((a_m<-a_l)||(a_l<a_m)) {a_value = COMPLEX(0);return false;}
  REAL value;
  if(!associated_legendre_polynomial(a_m,a_l,a_cos(a_theta),value,a_sqrt)) {a_value = COMPLEX(0);return false;}
  REAL factor;
  if(!y_l_m(a_m,a_l,factor,a_sqrt,a_pi)) return false;
  REAL phase = REAL(a_m)*a_phi;
  a_value = factor*value*(a_cos(phase)+COMPLEX(0,1)*a_sin(phase));
  return true;
}

template <class INT,class REAL>
inline bool cos_spherical_harmonic(const INT& a_m,const INT& a_l,
                               const REAL& a_theta,const REAL& a_phi,
                               REAL& a_value,
			       REAL(*a_sqrt)(const REAL&),
			       REAL(*a_sin)(const REAL&),
			       REAL(*a_cos)(const REAL&),
			       const REAL& a_pi) {
  if((a_m<-a_l)||(a_l<a_m)) {a_value = REAL(0);return false;}
  REAL value;
  if(!associated_legendre_polynomial(a_m,a_l,a_cos(a_theta),value,a_sqrt)) {a_value = 0;return false;}
  REAL factor;
  if(!y_l_m(a_m,a_l,factor,a_sqrt,a_pi)) return false;
  a_value = factor*value*a_cos(REAL(a_m)*a_phi);
  return true;
}

template <class INT,class REAL>
inline bool sin_spherical_harmonic(const INT& a_m,const INT& a_l,
                               const REAL& a_theta,const REAL& a_phi,
                               REAL& a_value,
			       REAL(*a_sqrt)(const REAL&),
			       REAL(*a_sin)(const REAL&),
			       REAL(*a_cos)(const REAL&),
			       const REAL& a_pi) {
  if((a_m<-a_l)||(a_l<a_m)) {a_value = REAL(0);return false;}
  REAL value;
  if(!associated_legendre_polynomial(a_m,a_l,a_cos(a_theta),value,a_sqrt)) {a_value = 0;return false;}
  REAL factor;
  if(!y_l_m(a_m,a_l,factor,a_sqrt,a_pi)) return false;
  a_value = factor*value*a_sin(REAL(a_m)*a_phi);
  return true;
}

}

/*
#include <cmath>
inline void check_assiociated_legendre_polynomial() {double value;inlib::associated_legendre_polynomial(10,11,1.0,value,::sqrt);}

#include "mathd"
#include <complex>
inline void check_spherical_harmonic() {
  std::complex<double> value;
  inlib::spherical_harmonic<int, std::complex<double> >(-1,2,1.0,1.0,value,::sqrt,::cos,::sin,inlib::pi());
}
*/

#endif
