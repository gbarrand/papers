// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_op_func
#define inlib_op_func

// used in exlib/tests/gmp.cpp.

#ifdef INLIB_MEM
#include "mem"
#endif

#include <ostream>

namespace inlib {

template <class REAL>
class op_func {
#ifdef INLIB_MEM
  static const std::string& s_class() {
    static const std::string s_v("inlib::op_func");
    return s_v;
  }
#endif
public:
  virtual bool value(const REAL&,REAL&) const = 0;
public:
  op_func(){
#ifdef INLIB_MEM
    mem::increment(s_class().c_str());
#endif
  }
  virtual ~op_func(){
#ifdef INLIB_MEM
    mem::decrement(s_class().c_str());
#endif
  }
public:
  op_func(const op_func&){
#ifdef INLIB_MEM
    mem::increment(s_class().c_str());
#endif
  }
  op_func& operator=(const op_func&){return *this;}
};

template <class UINT,class REAL>
class op_derivative : public op_func<REAL> {
  typedef op_func<REAL> parent;
protected:
  typedef void(*set_prec_from_func)(REAL&,const REAL&);
  typedef void(*fabs_func)(const REAL&,REAL&);
public:
  virtual bool value(const REAL& a_x,REAL& a_v) const {
    REAL zero;m_set_prec_from(zero,a_v);zero = 0;

    REAL epsilon;m_set_prec_from(epsilon,a_v);epsilon = m_epsilon;

    REAL prev;m_set_prec_from(prev,a_v);
    REAL diff;m_set_prec_from(diff,a_v);
    REAL prev_diff;m_set_prec_from(prev_diff,a_v);

    UINT count = 0;
    while(count<=m_iters) {
      if(!_value(a_x,epsilon,a_v)) {
        m_out << "inlib::op_derivative::_value : failed :"
              << " count " << count << ", x " << a_x
              << ", epsilon " << epsilon
              << "." << std::endl;
        a_v = zero;
        return false;
      }
      if(count>=1) {
        m_fabs(a_v-prev,diff);
        if(diff<=zero) break;
        if(count>=2) {
          if(diff>=prev_diff) {
            m_out << "inlib::op_derivative::value : failed :"
                  << " count " << count << ", x " << a_x
		  << ", value " << a_v << ", prev " << prev
		  << ", diff " << diff << " >= prev_diff " << prev_diff
                  << "." << std::endl;
          //m_out << " Continue..." << std::endl;
          //a_v = prev;
          //break;
            a_v = zero;
            return false;
          }
          if(count>=m_iters) {
            //m_out << "inlib::op_derivative::value : converge at " << count << ". value " << a_v << std::endl;
            break;
          }
        }
        prev_diff = diff;
      }
      epsilon *= m_factor;
      prev = a_v;
      count++;
    }
    return true;
  }
public:
  op_derivative(std::ostream& a_out,const op_func<REAL>& a_func,
                const REAL& a_epsilon,const REAL& a_factor,const UINT& a_iters,
                set_prec_from_func a_set_prec_from,fabs_func a_fabs)
  :parent(),m_out(a_out),m_func(a_func)
  ,m_epsilon(a_epsilon),m_factor(a_factor),m_iters(a_iters)
  ,m_set_prec_from(a_set_prec_from),m_fabs(a_fabs){
    if(!m_iters) {
      m_out << "inlib::op_derivative : a_iters must be >=1. Given 0 but enforce 1." << std::endl;
      m_iters = 1;
    }
  }
  virtual ~op_derivative(){}
public:
  op_derivative(const op_derivative& a_from)
  :parent(a_from),m_out(a_from.m_out),m_func(a_from.m_func)
  ,m_epsilon(a_from.m_epsilon),m_factor(a_from.m_factor),m_iters(a_from.m_iters)
  ,m_set_prec_from(a_from.m_set_prec_from),m_fabs(a_from.m_fabs){}
  op_derivative& operator=(const op_derivative& a_from){
    parent::operator=(a_from);
    m_epsilon = a_from.m_epsilon;
    m_factor = a_from.m_factor;
    m_iters = a_from.m_iters;
    m_set_prec_from = a_from.m_set_prec_from;
    m_fabs = a_from.m_fabs;
    return *this;
  }
protected:
  bool _value(const REAL& a_x,const REAL& a_epsil,REAL& a_value) const {
    REAL v_x;m_set_prec_from(v_x,a_value);
    if(!m_func.value(a_x,v_x)) {a_value = 0;return false;}
    REAL v_x_e;m_set_prec_from(v_x_e,a_value);
    if(!m_func.value(a_x+a_epsil,v_x_e)) {a_value = 0;return false;}
    a_value = (v_x_e-v_x)/a_epsil;
    return true;
  }
protected:
  std::ostream& m_out;
  const op_func<REAL>& m_func;
  REAL m_epsilon;
  REAL m_factor;
  UINT m_iters;
  set_prec_from_func m_set_prec_from;
  fabs_func m_fabs;
};

template <class UINT,class REAL>
class op_second_derivative : public op_func<REAL> {
  typedef op_func<REAL> parent;
protected:
  typedef void(*set_prec_from_func)(REAL&,const REAL&);
  typedef void(*fabs_func)(const REAL&,REAL&);
public:
  virtual bool value(const REAL& a_x,REAL& a_v) const {
    REAL zero;m_set_prec_from(zero,a_v);zero = 0;

    REAL epsilon;m_set_prec_from(epsilon,a_v);epsilon = m_epsilon;

    REAL prev;m_set_prec_from(prev,a_v);
    REAL diff;m_set_prec_from(diff,a_v);
    REAL prev_diff;m_set_prec_from(prev_diff,a_v);

    UINT count = 0;
    while(count<=m_iters) {
      if(!_value(a_x,epsilon,a_v)) {
        m_out << "inlib::op_second_derivative::_value : failed :"
              << " count " << count << ", x " << a_x
              << ", epsilon " << epsilon
              << "." << std::endl;
        a_v = zero;
        return false;
      }
      if(count>=1) {
        m_fabs(a_v-prev,diff);
        if(diff<=zero) break;
        if(count>=2) {
          if(diff>=prev_diff) {
            m_out << "inlib::op_second_derivative::value : failed :"
                  << " count " << count << ", x " << a_x
		  << ", value " << a_v << ", prev " << prev
		  << ", diff " << diff << " >= prev_diff " << prev_diff
                  << "." << std::endl;
          //m_out << " Continue..." << std::endl;
          //a_v = prev;
          //break;
            a_v = zero;
	    return false;
          }
          if(count>=m_iters) {
            //m_out << "inlib::op_second_derivative::value : converge at " << count << ". value " << a_v << std::endl;
            break;
          }
        }
        prev_diff = diff;
      }
      epsilon *= m_factor;
      prev = a_v;
      count++;
    }
    return true;
  }
public:
  op_second_derivative(std::ostream& a_out,const op_func<REAL>& a_func,
                       const REAL& a_epsilon,const REAL& a_factor,const UINT& a_iters,
                       set_prec_from_func a_set_prec_from,fabs_func a_fabs)
  :parent(),m_out(a_out),m_func(a_func)
  ,m_epsilon(a_epsilon),m_factor(a_factor),m_iters(a_iters)
  ,m_set_prec_from(a_set_prec_from),m_fabs(a_fabs){
    if(!m_iters) {
      m_out << "inlib::op_second_derivative : a_iters must be >=1. Given 0 but enforce 1." << std::endl;
      m_iters = 1;
    }
  }
  virtual ~op_second_derivative(){}
public:
  op_second_derivative(const op_second_derivative& a_from)
  :parent(a_from),m_out(a_from.m_out),m_func(a_from.m_func)
  ,m_epsilon(a_from.m_epsilon),m_factor(a_from.m_factor),m_iters(a_from.m_iters)
  ,m_set_prec_from(a_from.m_set_prec_from),m_fabs(a_from.m_fabs){}
  op_second_derivative& operator=(const op_second_derivative& a_from){
    parent::operator=(a_from);
    m_epsilon = a_from.m_epsilon;
    m_factor = a_from.m_factor;
    m_iters = a_from.m_iters;
    m_set_prec_from = a_from.m_set_prec_from;
    m_fabs = a_from.m_fabs;
    return *this;
  }
protected:
  bool _value(const REAL& a_x,const REAL& a_epsil,REAL& a_value) const {
    REAL v_x;m_set_prec_from(v_x,a_value);
    if(!m_func.value(a_x,v_x)) {a_value = 0;return false;}
    REAL v_x_e;m_set_prec_from(v_x_e,a_value);
    if(!m_func.value(a_x+a_epsil,v_x_e)) {a_value = 0;return false;}
    REAL v_x_2e;m_set_prec_from(v_x_2e,a_value);
    if(!m_func.value(a_x+a_epsil*2,v_x_2e)) {a_value = 0;return false;}
    a_value = (v_x_2e+v_x-v_x_e*2)/(a_epsil*a_epsil);
    return true;
  }
protected:
  std::ostream& m_out;
  const op_func<REAL>& m_func;
  REAL m_epsilon;
  REAL m_factor;
  UINT m_iters;
  set_prec_from_func m_set_prec_from;
  fabs_func m_fabs;
};

template <class UINT,class REAL>
class op_primitive : public op_func<REAL> {
  typedef op_func<REAL> parent;
protected:
  typedef void(*set_prec_from_func)(REAL&,const REAL&);
public:
  virtual bool value(const REAL& a_x,REAL& a_v) const {
    REAL zero;m_set_prec_from(zero,a_v);zero = 0;
    REAL v;m_set_prec_from(v,a_v);
    REAL steps;m_set_prec_from(steps,a_v);steps = m_steps;
    REAL step;m_set_prec_from(step,a_v);
    step = (a_x-m_a)/steps;
    REAL x;m_set_prec_from(x,a_v);x = m_a;
    a_v = zero;
    for(UINT i=0;i<=m_steps;i++) {
      if(!m_func.value(x,v)) {a_v = zero;return false;}
      a_v += v;
      x += step;
    }
    a_v *= step;
    return true;
  }
public:
  op_primitive(const op_func<REAL>& a_func,const REAL& a_a,const UINT& a_steps,set_prec_from_func a_set_prec_from)
  :parent()
  ,m_func(a_func)
  ,m_a(a_a)
  ,m_steps(a_steps)
  ,m_set_prec_from(a_set_prec_from)
  {}
  virtual ~op_primitive(){}
public:
  op_primitive(const op_primitive& a_from)
  :parent(a_from)
  ,m_func(a_from.m_func)
  ,m_a(a_from.m_a)
  ,m_steps(a_from.m_steps)
  ,m_set_prec_from(a_from.m_set_prec_from)
  {}
  op_primitive& operator=(const op_primitive& a_from){
    parent::operator=(a_from);
    m_a = a_from.m_a;
    m_steps = a_from.m_steps;
    m_set_prec_from = a_from.m_set_prec_from;
    return *this;
  }
protected:
  const op_func<REAL>& m_func;
  REAL m_a;
  UINT m_steps;
  set_prec_from_func m_set_prec_from;
};

template <class REAL>
class op_sqr : public op_func<REAL> {
  typedef op_func<REAL> parent;
public:
  virtual bool value(const REAL& a_x,REAL& a_v) const {
    if(!m_func.value(a_x,a_v)) return false;
    a_v *= a_v;
    return true;
  }
public:
  op_sqr(const op_func<REAL>& a_func):parent(),m_func(a_func){}
  virtual ~op_sqr(){}
public:
  op_sqr(const op_sqr& a_from):parent(a_from),m_func(a_from.m_func){}
  op_sqr& operator=(const op_sqr& a_from){parent::operator=(a_from);return *this;}
protected:
  const op_func<REAL>& m_func;
};

template <class REAL>
class op_mult : public op_func<REAL> {
  typedef op_func<REAL> parent;
protected:
  typedef void(*set_prec_from_func)(REAL&,const REAL&);
public:
  virtual bool value(const REAL& a_x,REAL& a_v) const {
    if(!m_f1.value(a_x,a_v)) return false;
    REAL v2;m_set_prec_from(v2,a_v);
    if(!m_f2.value(a_x,v2)) return false;
    a_v *= v2;
    return true;
  }
public:
  op_mult(const op_func<REAL>& a_f1,const op_func<REAL>& a_f2,set_prec_from_func a_set_prec_from)
  :parent(),m_f1(a_f1),m_f2(a_f2),m_set_prec_from(a_set_prec_from){}
  virtual ~op_mult(){}
public:
  op_mult(const op_mult& a_from):parent(a_from),m_f1(a_from.m_f1),m_f2(a_from.m_f2)
  ,m_set_prec_from(a_from.m_set_prec_from){}
  op_mult& operator=(const op_mult& a_from){
    parent::operator=(a_from);
    m_set_prec_from = a_from.m_set_prec_from;
    return *this;
  }
protected:
  const op_func<REAL>& m_f1;
  const op_func<REAL>& m_f2;
  set_prec_from_func m_set_prec_from;
};

}

#endif
