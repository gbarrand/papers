// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_check_dirac_radial
#define inlib_check_dirac_radial

#ifdef INLIB_MEM
#include <inlib/mem>
#endif //INLIB_MEM

#include <inlib/op_func>

#include <inlib/dirac_radial>

namespace inlib {
namespace dirac {

class LL_f_discrete : public inlib::op_func<inlib::real> {
  typedef inlib::real real;
  typedef inlib::op_func<real> parent;
public:
  virtual bool value(const real& a_x,real& a_value) const {
    return BLP_f_discrete(m_out,m_params,a_x,a_value);
  }
public:
  LL_f_discrete(std::ostream& a_out,const params& a_params)
  :parent(),m_out(a_out),m_params(a_params) {
  }
  virtual ~LL_f_discrete(){}
public:
  LL_f_discrete(const LL_f_discrete& a_from)
  :parent(a_from)
  ,m_out(a_from.m_out)
  ,m_params(a_from.m_params)
  {}
  LL_f_discrete& operator=(const LL_f_discrete& a_from){
    parent::operator=(a_from);
    m_params = a_from.m_params;
    return *this;
  }
protected:
  std::ostream& m_out;
  params m_params;
};

class LL_g_discrete : public inlib::op_func<inlib::real> {
  typedef inlib::real real;
  typedef inlib::op_func<real> parent;
public:
  virtual bool value(const real& a_x,real& a_value) const {
    return BLP_g_discrete(m_out,m_params,a_x,a_value);
  }
public:
  LL_g_discrete(std::ostream& a_out,const params& a_params)
  :parent(),m_out(a_out),m_params(a_params)
  {}
  virtual ~LL_g_discrete(){}
public:
  LL_g_discrete(const LL_g_discrete& a_from)
  :parent(a_from),m_out(a_from.m_out),m_params(a_from.m_params)
  {}
  LL_g_discrete& operator=(const LL_g_discrete& a_from){
    parent::operator=(a_from);
    m_params = a_from.m_params;
    return *this;
  }
protected:
  std::ostream& m_out;
  params m_params;
};

}}

#include <inlib/integrate>

namespace inlib {
namespace dirac {

class norm_func_discrete : public virtual inlib::integrate_func_1D<inlib::real,inlib::real> {
  typedef inlib::integrate_func_1D<inlib::real,inlib::real> parent;
public:
  norm_func_discrete(std::ostream& a_out,const params& a_params):m_out(a_out),m_params(a_params) {}
  virtual ~norm_func_discrete() {}
public:
  norm_func_discrete(std::ostream& a_out,const norm_func_discrete& a_from)
  :parent(a_from),m_out(a_from.m_out),m_params(a_from.m_params) {}
  norm_func_discrete& operator=(const norm_func_discrete& a_from) {
    m_params = a_from.m_params;
    return *this;
  }
public:
  virtual bool eval(const inlib::real& a_x,inlib::real& a_value) {
    inlib::real f;
    if(!BLP_f_discrete(m_out,m_params,a_x,f)) {a_value = 0;return false;}
    inlib::real g;
    if(!BLP_g_discrete(m_out,m_params,a_x,g)) {a_value = 0;return false;}
    a_value = a_x*a_x*(f*f+g*g);
    //::printf("debug : x %Lg, f %Lg, g %Lg\n",a_x,f,g);
    return true;
  }
protected:
  std::ostream& m_out;
  params m_params;
};

}}

namespace inlib {
namespace dirac {

class LL_f_continuous : public inlib::op_func<inlib::real> {
  typedef inlib::real real;
  typedef inlib::op_func<real> parent;
public:
  virtual bool value(const real& a_x,real& a_value) const {
    return BLP_f_continuous(m_out,m_params,a_x,a_value);
  }
public:
  LL_f_continuous(std::ostream& a_out,const params& a_params)
  :parent(),m_out(a_out),m_params(a_params) {
  }
  virtual ~LL_f_continuous(){}
public:
  LL_f_continuous(const LL_f_continuous& a_from)
  :parent(a_from)
  ,m_out(a_from.m_out)
  ,m_params(a_from.m_params)
  {}
  LL_f_continuous& operator=(const LL_f_continuous& a_from){
    parent::operator=(a_from);
    m_params = a_from.m_params;
    return *this;
  }
protected:
  std::ostream& m_out;
  params m_params;
};

class LL_g_continuous : public inlib::op_func<inlib::real> {
  typedef inlib::real real;
  typedef inlib::op_func<real> parent;
public:
  virtual bool value(const real& a_x,real& a_value) const {
    return BLP_g_continuous(m_out,m_params,a_x,a_value);
  }
public:
  LL_g_continuous(std::ostream& a_out,const params& a_params)
  :parent(),m_out(a_out),m_params(a_params)
  {}
  virtual ~LL_g_continuous(){}
public:
  LL_g_continuous(const LL_g_continuous& a_from)
  :parent(a_from),m_out(a_from.m_out),m_params(a_from.m_params)
  {}
  LL_g_continuous& operator=(const LL_g_continuous& a_from){
    parent::operator=(a_from);
    m_params = a_from.m_params;
    return *this;
  }
protected:
  std::ostream& m_out;
  params m_params;
};

class norm_func_continuous : public virtual inlib::integrate_func_1D<inlib::real,inlib::real> {
  typedef inlib::integrate_func_1D<inlib::real,inlib::real> parent;
public:
  norm_func_continuous(std::ostream& a_out,const params& a_params):m_out(a_out),m_params(a_params) {}
  virtual ~norm_func_continuous() {}
public:
  norm_func_continuous(std::ostream& a_out,const norm_func_continuous& a_from)
  :parent(a_from),m_out(a_from.m_out),m_params(a_from.m_params) {}
  norm_func_continuous& operator=(const norm_func_continuous& a_from) {
    m_params = a_from.m_params;
    return *this;
  }
public:
  virtual bool eval(const inlib::real& a_x,inlib::real& a_value) {
    inlib::real f;
    if(!BLP_f_continuous(m_out,m_params,a_x,f)) {a_value = 0;return false;}
    inlib::real g;
    if(!BLP_g_continuous(m_out,m_params,a_x,g)) {a_value = 0;return false;}
    a_value = a_x*a_x*(f*f+g*g);
    //::printf("debug : x %Lg, f %Lg, g %Lg\n",a_x,f,g);
    return true;
  }
protected:
  std::ostream& m_out;
  params m_params;
};

class for_zgamma : public virtual inlib::integrate_func_1D<inlib::real,std::complex<inlib::real> > {
  typedef std::complex<inlib::real> zreal;
  typedef inlib::integrate_func_1D<inlib::real,zreal> parent;
public:
  for_zgamma(const zreal& a_z):m_z(a_z) {}
  virtual ~for_zgamma() {}
public:
  for_zgamma(std::ostream& a_out,const for_zgamma& a_from):m_z(a_from.m_z) {}
  for_zgamma& operator=(const for_zgamma& a_from) {m_z = a_from.m_z;return *this;}
public:
  virtual bool eval(const inlib::real& a_x,zreal& a_value) {
    a_value = std::pow(a_x,m_z-zreal(1))*inlib::real_exp(-a_x);
    return true;
  }
protected:
  zreal m_z;
};

}}

#include <inlib/eqT>

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
#include <inlib/test>
#include <inlib/mathT>

inline bool check_dirac_radial_x2(std::ostream& a_out,bool a_verbose,unsigned int a_prec = 1024) {
  // Check solution of Dirac equation with x**2 potential :

  inlib::real LL_alpha = 0.9;
  inlib::real alpha_2 = LL_alpha*LL_alpha;
  inlib::real LL_v = 1.1;
  if(a_verbose) a_out << "LL_v " << LL_v << std::endl;

  inlib::real dxepsil(1e-3);
  inlib::real dxfactor(0.5);
  unsigned int dxiters = 5;  //=> dxepsil*(dxfactor**dxiters)

  inlib::real depsilon = 1e-3;
  
 {for(inlib::real LL_chi=2;LL_chi<=4;LL_chi++) { //can't be 0 or 1.

  inlib::real chi_2 = LL_chi*LL_chi;
  if(chi_2<alpha_2) {
    a_out << "check_dirac_radial: chi_2 < alpha_2: " << chi_2 << std::endl;
    a_out << "alpha_2: " << alpha_2 << std::endl;
    return false;
  }

  if(a_verbose) a_out << "LL_chi " << LL_chi << std::endl;

  inlib::real LL_gamma = inlib::real_sqrt(inlib::real_fabs(chi_2-alpha_2));

  //inlib::real LL_nr = 1;  //can't be 0. ok with 1.2, but does f(r), g(r) "well-behaved" ?
 {for(inlib::real LL_nr=1;LL_nr<=3;LL_nr++) { //can't be 0 to have f(r), g(r) "well-behaved".
 
  if(a_verbose) a_out << "LL_nr " << LL_nr << std::endl;

  inlib::real nr_gamma = LL_nr+LL_gamma;
  inlib::real LL_u = LL_v/inlib::real_sqrt(1+alpha_2/(nr_gamma*nr_gamma));
  if(a_verbose) a_out << "LL_u " << LL_u << std::endl;

  inlib::dirac::params params(LL_chi,LL_alpha,LL_v,LL_u);

  inlib::real LL_lambda = inlib::real_sqrt(inlib::real_fabs(LL_v*LL_v-LL_u*LL_u));
  if(a_verbose) a_out << "LL_lambda " << LL_lambda << std::endl;
  if(a_verbose) a_out << "LL_gamma " << LL_gamma << std::endl;
  if(a_verbose) a_out << "2*LL_gamma+1 " << (2*LL_gamma+1) << std::endl;

  //cross-check: 1F1 a:
  inlib::real a_1F1 = LL_gamma - LL_alpha*LL_u/LL_lambda;
  if(!inlib::numbers_are_equal(LL_nr,-a_1F1,depsilon,inlib::real_fabs_const)) {
    a_out << "check_dirac_radial -a_1F1 problem: " << -a_1F1<< std::endl;
    a_out << "expected: nr " << LL_nr << std::endl;
    return false;
  }

#ifdef INLIB_DIRAC_KUMMER_U
#else
  if((LL_chi<=inlib::real_three())&&(LL_nr<=inlib::real_two()))
 {inlib::dirac::norm_func_discrete func(a_out,params);
  inlib::real value;
//if(!inlib::integrate_1D<unsigned int,inlib::real>(2000,0,70,func,value,inlib::real(1.e-3),inlib::real_fabs_const)) {
  if(!inlib::integrate_1D<unsigned int,inlib::real>(2000,0,70,func,value)) {
    a_out << "check_dirac_radial: integration problem:" << std::endl;
    return false;
  }
  inlib::real nr_fac;
  inlib::factorial<unsigned int,inlib::real>((unsigned int)LL_nr,nr_fac);
  inlib::real alpha_v_over_lambda = LL_alpha*LL_v/LL_lambda;
  inlib::real factor = 2*inlib::real_gamma(2*LL_gamma+1+LL_nr)*(alpha_v_over_lambda-LL_chi)/(nr_fac*LL_alpha);
  inlib::real A = inlib::real_sqrt(inlib::real_fabs(factor))/inlib::real_gamma(2*LL_gamma+1);
  A *= LL_lambda*LL_lambda/LL_v;
  if(!inlib::numbers_are_equal(A*A*value,inlib::real_one(),depsilon,inlib::real_fabs_const)) {
    a_out << "check_dirac_radial integration problem:" << std::endl;
    a_out << A*A*value << " != " << 1 << std::endl;
    a_out << "LL_nr " << LL_nr << ", LL_chi " << LL_chi << std::endl;
    return false;
  }}
#endif

  inlib::dirac::LL_f_discrete f(a_out,params);
  inlib::dirac::LL_g_discrete g(a_out,params);

  inlib::op_derivative<unsigned int,inlib::real>
    f_deriv(a_out,f,dxepsil,dxfactor,dxiters,inlib::real_set_prec_from,inlib::real_fabs_const);
  inlib::op_derivative<unsigned int,inlib::real>
    g_deriv(a_out,g,dxepsil,dxfactor,dxiters,inlib::real_set_prec_from,inlib::real_fabs_const);

  inlib::real factor_r = 1.0/(2.*LL_lambda);
  if(a_verbose) a_out << "factor_r " << factor_r << std::endl;

 {for(inlib::real _r=0.1;_r<2;_r+=0.4) {
  inlib::real r = factor_r*_r;

  //if(a_verbose)
  //a_out << "r " << r << std::endl;

  inlib::real f_value;
  if(!f.value(r,f_value)) return false;
  if(a_verbose) a_out << "f_value " << f_value << std::endl;

  inlib::real g_value;
  if(!g.value(r,g_value)) return false;
  if(a_verbose) a_out << "g_value " << g_value << std::endl;

  inlib::real f_deriv_value;
  if(!f_deriv.value(r,f_deriv_value)) return false;
  if(a_verbose) a_out << "f_deriv_value " << f_deriv_value << std::endl;

  inlib::real g_deriv_value;
  if(!g_deriv.value(r,g_deriv_value)) return false;
  if(a_verbose) a_out << "g_deriv_value " << g_deriv_value << std::endl;

  inlib::real f_equation = f_deriv_value + (1+LL_chi)*f_value/r-(LL_alpha/r+LL_u+LL_v)*g_value;
  inlib::real g_equation = g_deriv_value + (1-LL_chi)*g_value/r+(LL_alpha/r+LL_u-LL_v)*f_value;

  if(a_verbose) a_out << "f_equation " << f_equation << std::endl;
  if(a_verbose) a_out << "g_equation " << g_equation << std::endl;

  if(!inlib::numbers_are_equal(f_equation,inlib::real_zero(),depsilon,inlib::real_fabs_const)) {
    a_out << "check_dirac_radial f problem:" << std::endl;
    return false;
  }

  if(!inlib::numbers_are_equal(g_equation,inlib::real_zero(),depsilon,inlib::real_fabs_const)) {
    a_out << "check_dirac_radial g problem:" << std::endl;
    a_out << "g_equation " << g_equation << " != 0" << std::endl;
    return false;
  }
  
  }} //end for(r)

  }} //end for(LL_nr)
  }} //end for(LL_chi)

  return true;
}

inline bool check_dirac_radial_x2_continuous(std::ostream& a_out,bool a_verbose,unsigned int a_prec = 1024) {
  // Check continuous spectrum solution of Dirac equation with x**2 potential :

  //inlib::real LL_alpha = inlib::edep::fine_structure_const;
  inlib::real LL_alpha = 0.9;
  inlib::real alpha_2 = LL_alpha*LL_alpha;
  inlib::real LL_v = 1.1;
//inlib::real LL_v = inlib::edep::electron_mass*inlib::edep::c_light/inlib::edep::hbar_Planck;
  if(a_verbose) a_out << "LL_v " << LL_v << std::endl;

  inlib::real dxepsil(1e-3);
  inlib::real dxfactor(0.5);
  unsigned int dxiters = 5;  //=> dxepsil*(dxfactor**dxiters)

  inlib::real depsilon = 1e-2;
  
 {for(inlib::real LL_chi=2;LL_chi<=4;LL_chi++) { //can't be 0 or 1.

  inlib::real chi_2 = LL_chi*LL_chi;
  if(chi_2<alpha_2) {
    a_out << "check_dirac_radial_continuous: chi_2 < alpha_2: " << chi_2 << std::endl;
    a_out << "alpha_2: " << alpha_2 << std::endl;
    return false;
  }

  if(a_verbose) a_out << "LL_chi " << LL_chi << std::endl;

  inlib::real LL_gamma = inlib::real_sqrt(inlib::real_fabs(chi_2-alpha_2));

 {for(inlib::real _u=1.1;_u<=2;_u+=0.1) {
  // v < |u|
  //inlib::real LL_u = -LL_v*_u;  //epsilon=sg(v+u)=-1
  inlib::real LL_u = LL_v*_u;  //epsilon=sg(v+u)=1
  if(a_verbose) a_out << "LL_u " << LL_u << std::endl;
  //a_out << "LL_v+LL_u " << LL_v+LL_u << std::endl;

  inlib::dirac::params params(LL_chi,LL_alpha,LL_v,LL_u);

  inlib::real LL_lambda = inlib::real_sqrt(inlib::real_fabs(LL_v*LL_v-LL_u*LL_u));
  if(a_verbose) a_out << "LL_lambda " << LL_lambda << std::endl;
  if(a_verbose) a_out << "LL_gamma " << LL_gamma << std::endl;
  if(a_verbose) a_out << "2*LL_gamma+1 " << (2*LL_gamma+1) << std::endl;

#ifdef INLIB_DIRAC_KUMMER_U
#else
//if((LL_chi<=inlib::real_three())&&(LL_nr<=inlib::real_two()))
  if(false)
 {inlib::dirac::norm_func_continuous func(a_out,params);
  inlib::real value;
  if(!inlib::integrate_1D<unsigned int,inlib::real>(10000,0,40,func,value)) { //>40, we reach long-double precision.
    a_out << "check_dirac_radial_continuous: integration problem:" << std::endl;
    return false;
  }
  a_out << "continuous: integrale " << value << std::endl;
  inlib::real alpha_u_over_lambda = LL_alpha*LL_u/LL_lambda;
  typedef std::complex<inlib::real> zreal;
  zreal LL_eta(0,1);
  
  zreal gamma_num;
 {inlib::dirac::for_zgamma func(LL_gamma+1-alpha_u_over_lambda/LL_eta);
  if(!inlib::integrate_1D<unsigned int,inlib::real>(2000,0,70,func,gamma_num)) {
    a_out << "check_dirac_radial_continuous: integration problem:" << std::endl;
    return false;
  }}
  
  inlib::real A = std::abs(gamma_num);
  A /= inlib::real_gamma(2*LL_gamma+1);
  A *= inlib::real_exp(inlib::real_pi()*alpha_u_over_lambda/inlib::real_two());
  A *= LL_lambda/inlib::real_sqrt(inlib::real_pi()*inlib::real_fabs(LL_u));
  if(!inlib::numbers_are_equal(A*A*value,inlib::real_one(),depsilon,inlib::real_fabs_const)) {
    a_out << "check_dirac_radial_continuous: integration problem:" << std::endl;
    a_out << A*A*value << " != " << 1 << std::endl;
    a_out << "value " << value << std::endl;
    a_out << "A " << A << std::endl;
    a_out << "LL_chi " << LL_chi << ", LL_u " << LL_u << std::endl;
    return false;
  }}
#endif

  inlib::dirac::LL_f_continuous f(a_out,params);
  inlib::dirac::LL_g_continuous g(a_out,params);

  inlib::op_derivative<unsigned int,inlib::real>
    f_deriv(a_out,f,dxepsil,dxfactor,dxiters,inlib::real_set_prec_from,inlib::real_fabs_const);
  inlib::op_derivative<unsigned int,inlib::real>
    g_deriv(a_out,g,dxepsil,dxfactor,dxiters,inlib::real_set_prec_from,inlib::real_fabs_const);

  inlib::real factor_r = 1.0/(2.*LL_lambda);
  if(a_verbose) a_out << "factor_r " << factor_r << std::endl;

 {for(inlib::real _r=0.1;_r<2;_r+=0.4) {
  inlib::real r = factor_r*_r;

  //if(a_verbose)
  //a_out << "chi " << LL_chi << ", r " << r << std::endl;

  inlib::real f_value;
  if(!f.value(r,f_value)) return false;
  if(a_verbose) a_out << "f_value " << f_value << std::endl;

  inlib::real g_value;
  if(!g.value(r,g_value)) return false;
  if(a_verbose) a_out << "g_value " << g_value << std::endl;

  inlib::real f_deriv_value;
  if(!f_deriv.value(r,f_deriv_value)) return false;
  if(a_verbose) a_out << "f_deriv_value " << f_deriv_value << std::endl;

  inlib::real g_deriv_value;
  if(!g_deriv.value(r,g_deriv_value)) return false;
  if(a_verbose) a_out << "g_deriv_value " << g_deriv_value << std::endl;

  inlib::real f_equation = f_deriv_value + (1+LL_chi)*f_value/r-(LL_alpha/r+LL_u+LL_v)*g_value;
  inlib::real g_equation = g_deriv_value + (1-LL_chi)*g_value/r+(LL_alpha/r+LL_u-LL_v)*f_value;

  if(a_verbose) a_out << "f_equation " << f_equation << std::endl;
  if(a_verbose) a_out << "g_equation " << g_equation << std::endl;

  if(!inlib::numbers_are_equal(f_equation,inlib::real_zero(),depsilon,inlib::real_fabs_const)) {
    a_out << "check_dirac_radial_continuous: f problem:" << std::endl;
    a_out << "f_equation " << f_equation << " != 0" << std::endl;
    return false;
  }

  if(!inlib::numbers_are_equal(g_equation,inlib::real_zero(),depsilon,inlib::real_fabs_const)) {
    a_out << "check_dirac_radial_continuous: g problem:" << std::endl;
    a_out << "g_equation " << g_equation << " != 0" << std::endl;
    return false;
  }

  }} //end for(r)

  }} //end for(_u)

  }} //end for(LL_chi)

  return true;
}


#endif
