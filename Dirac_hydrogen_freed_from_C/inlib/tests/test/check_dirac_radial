// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_check_dirac_radial
#define inlib_check_dirac_radial

#ifdef INLIB_MEM
#include <inlib/mem>
#endif //INLIB_MEM

#include <inlib/op_func>

#include <inlib/mp_real>

#include <inlib/real>

#include <inlib/edep/physical_constants>

namespace inlib {
namespace dirac {

class params {
public:
  params(const inlib::real& a_LL_chi,
         const inlib::real& a_LL_alpha,
         const inlib::real& a_LL_v,
         const inlib::real& a_LL_u)
  :LL_chi(a_LL_chi)
  ,LL_alpha(a_LL_alpha)
  ,LL_v(a_LL_v)
  ,LL_u(a_LL_u)
  {}
  virtual ~params() {}
public:
  params(const params& a_from)
  :LL_chi(a_from.LL_chi)
  ,LL_alpha(a_from.LL_alpha)
  ,LL_v(a_from.LL_v)
  ,LL_u(a_from.LL_u)
  {}
  params& operator=(const params& a_from) {
    LL_chi = a_from.LL_chi;
    LL_alpha = a_from.LL_alpha;
    LL_v = a_from.LL_v;
    LL_u = a_from.LL_u;
    return *this;
  }
public:
  inlib::real LL_chi;
  inlib::real LL_alpha;
  inlib::real LL_v;
  inlib::real LL_u;
};

class LL_f : public inlib::op_func<inlib::real> {
  typedef inlib::real real;
  typedef inlib::op_func<real> parent;
public:
  virtual bool value(const real& a_x,real& a_value) const {
    real LL_chi = m_params.LL_chi;
    real LL_alpha = m_params.LL_alpha;
    real LL_v = m_params.LL_v;
    real LL_u = m_params.LL_u;

    real LL_lambda = inlib::real_sqrt(LL_v*LL_v-LL_u*LL_u);
    real LL_gamma = inlib::real_sqrt(LL_chi*LL_chi-LL_alpha*LL_alpha);
    real factor_1 = LL_gamma-LL_alpha*LL_u/LL_lambda;
    real factor_2 = LL_chi-LL_alpha*LL_u/LL_lambda;
    real A(1);
    real B = -A*factor_1/factor_2;

    real kummer_b = inlib::real_two()*LL_gamma+1;

    real rho = 2*LL_lambda*a_x;
    //m_out << "a_x " << a_x << ", rho " << rho << std::endl;

    real Q1;
    if(!inlib::mp_kummer_M<real>
      (m_out,factor_1,kummer_b,rho,Q1,
       inlib::real_set_prec_from,inlib::real_epsilon,inlib::real_fabs_const)) return false;
    //m_out << "Q1 " << Q1 << std::endl;
    Q1 *= A;
    
    real Q2;
    if(!inlib::mp_kummer_M<real>
      (m_out,factor_1+1,kummer_b,rho,Q2,
       inlib::real_set_prec_from,inlib::real_epsilon,inlib::real_fabs_const)) return false;
    //m_out << "Q2 " << Q2 << std::endl;
    Q2 *= B;

    a_value = inlib::real_sqrt(LL_v+LL_u)*inlib::real_exp(-LL_lambda*a_x)*inlib::real_pow(rho,LL_gamma-1)*(Q1+Q2);
    
    return true;
  }
public:
  LL_f(std::ostream& a_out,const params& a_params)
  :parent(),m_out(a_out),m_params(a_params) {
  }
  virtual ~LL_f(){}
public:
  LL_f(const LL_f& a_from)
  :parent(a_from)
  ,m_out(a_from.m_out)
  ,m_params(a_from.m_params)
  {}
  LL_f& operator=(const LL_f& a_from){
    parent::operator=(a_from);
    m_params = a_from.m_params;
    return *this;
  }
protected:
  std::ostream& m_out;
  params m_params;
};

class LL_g : public inlib::op_func<inlib::real> {
  typedef inlib::real real;
  typedef inlib::op_func<real> parent;
public:
  virtual bool value(const real& a_x,real& a_value) const {
    real LL_chi = m_params.LL_chi;
    real LL_alpha = m_params.LL_alpha;
    real LL_v = m_params.LL_v;
    real LL_u = m_params.LL_u;

    real LL_lambda = inlib::real_sqrt(LL_v*LL_v-LL_u*LL_u);
    real LL_gamma = inlib::real_sqrt(LL_chi*LL_chi-LL_alpha*LL_alpha);
    real factor_1 = LL_gamma-LL_alpha*LL_u/LL_lambda;
    real factor_2 = LL_chi-LL_alpha*LL_u/LL_lambda;
    real A(1);
    real B = -A*factor_1/factor_2;

    real kummer_b = inlib::real_two()*LL_gamma+1;

    real rho = 2*LL_lambda*a_x;

    real Q1;
    if(!inlib::mp_kummer_M<real>
      (m_out,factor_1,kummer_b,rho,Q1,
       inlib::real_set_prec_from,inlib::real_epsilon,inlib::real_fabs_const)) return false;
    Q1 *= A;

    real Q2;
    if(!inlib::mp_kummer_M<real>
      (m_out,factor_1+1,kummer_b,rho,Q2,
       inlib::real_set_prec_from,inlib::real_epsilon,inlib::real_fabs_const)) return false;
    Q2 *= B;

    a_value = -inlib::real_sqrt(LL_v-LL_u)*inlib::real_exp(-LL_lambda*a_x)*inlib::real_pow(rho,LL_gamma-1)*(Q1-Q2);

    return true;
  }
public:
  LL_g(std::ostream& a_out,const params& a_params)
  :parent(),m_out(a_out),m_params(a_params)
  {}
  virtual ~LL_g(){}
public:
  LL_g(const LL_g& a_from)
  :parent(a_from),m_out(a_from.m_out),m_params(a_from.m_params)
  {}
  LL_g& operator=(const LL_g& a_from){
    parent::operator=(a_from);
    m_params = a_from.m_params;
    return *this;
  }
protected:
  std::ostream& m_out;
  params m_params;
};

}}

#include <inlib/eqT>

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
#include <inlib/test>

inline bool check_dirac_radial_x2(std::ostream& a_out,bool a_verbose,unsigned int a_prec = 1024) {
  // Check solution of Dirac equation with x**2 potential :

  inlib::real LL_alpha = inlib::edep::fine_structure_const;
  inlib::real alpha_2 = LL_alpha*LL_alpha;
  inlib::real LL_v = 1;
//inlib::real LL_v = inlib::edep::electron_mass*inlib::edep::c_light/inlib::edep::hbar_Planck;
  if(a_verbose) a_out << "LL_v " << LL_v << std::endl;

  inlib::real dxepsil(1e-3);
  inlib::real dxfactor(0.5);
  unsigned int dxiters = 5;  //=> dxepsil*(dxfactor**dxiters)

  inlib::real LL_chi = 3; //can't be 0 or 1.
  inlib::real LL_nr = 1;  //ok with 1.2, but does f(r), g(r) "well-behaved" ?

 {for(LL_nr=0;LL_nr<=1;LL_nr++) {
 {for(LL_chi=2;LL_chi<=4;LL_chi++) {

  inlib::real LL_gamma = inlib::real_sqrt(LL_chi*LL_chi-alpha_2);
  inlib::real LL_u = LL_v/inlib::real_sqrt(1+alpha_2/(LL_nr+LL_gamma));
  if(a_verbose) a_out << "LL_u " << LL_u << std::endl;

  inlib::real LL_lambda = inlib::real_sqrt(LL_v*LL_v-LL_u*LL_u);
  if(a_verbose) a_out << "LL_lambda " << LL_lambda << std::endl;
  if(a_verbose) a_out << "LL_gamma " << LL_gamma << std::endl;

  inlib::dirac::params params(LL_chi,LL_alpha,LL_v,LL_u);
  inlib::dirac::LL_f f(a_out,params);
  inlib::dirac::LL_g g(a_out,params);

  inlib::op_derivative<unsigned int,inlib::real>
    f_deriv(a_out,f,dxepsil,dxfactor,dxiters,inlib::real_set_prec_from,inlib::real_fabs_const);
  inlib::op_derivative<unsigned int,inlib::real>
    g_deriv(a_out,g,dxepsil,dxfactor,dxiters,inlib::real_set_prec_from,inlib::real_fabs_const);

  inlib::real factor_r = 1.0/(2.*LL_lambda);

 {for(inlib::real r=0.1;r<2;r+=0.1) {
  r *= factor_r;

  inlib::real f_value;
  if(!f.value(r,f_value)) return false;
  if(a_verbose) a_out << "f_value " << f_value << std::endl;

  inlib::real g_value;
  if(!g.value(r,g_value)) return false;
  if(a_verbose) a_out << "g_value " << g_value << std::endl;

  inlib::real f_deriv_value;
  if(!f_deriv.value(r,f_deriv_value)) return false;
  if(a_verbose) a_out << "f_deriv_value " << f_deriv_value << std::endl;

  inlib::real g_deriv_value;
  if(!g_deriv.value(r,g_deriv_value)) return false;
  if(a_verbose) a_out << "g_deriv_value " << g_deriv_value << std::endl;

  inlib::real f_equation = f_deriv_value + (1+LL_chi)*f_value/r-(LL_alpha/r+LL_u+LL_v)*g_value;
  inlib::real g_equation = g_deriv_value + (1-LL_chi)*g_value/r+(LL_alpha/r+LL_u-LL_v)*g_value;

  inlib::real depsilon = 1e-3;

  if(a_verbose) a_out << "f_equation " << f_equation << std::endl;
  if(a_verbose) a_out << "g_equation " << g_equation << std::endl;

  if(!inlib::numbers_are_equal(f_equation,inlib::real_zero(),depsilon,inlib::real_fabs_const)) {
    a_out << "check_dirac_radial f problem:" << std::endl;
    return false;
  }
  
  if(!inlib::numbers_are_equal(g_equation,inlib::real_zero(),depsilon,inlib::real_fabs_const)) {
    a_out << "check_dirac_radial g problem:" << std::endl;
    return false;
  }
  
  }} //end for(r)
  }} //end for(LL_chi)
  }} //end for(LL_nr)

  return true;
}


#endif
