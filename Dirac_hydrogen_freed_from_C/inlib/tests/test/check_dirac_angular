// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_check_dirac_angular
#define inlib_check_dirac_angular

#ifdef INLIB_MEM
#include <inlib/mem>
#endif //INLIB_MEM

#include <inlib/lina/mat>
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//#include <inlib/lina/matTs>
namespace inlib {
////////////////////////////////////////////////
/// D=2 ////////////////////////////////////////
////////////////////////////////////////////////
//  Pauli matrices :
//  P1      P2      P3
//    0  1    0 -i    1  0
//    1  0    i  0    0 -1
template <class MAT>
inline void set_P1(MAT& a_m) {
  matrix_set<MAT>(a_m,  0, 1,
                        1, 0);
}

template <class MAT>
inline void set_P2(MAT& a_m) {
  typedef typename MAT::elem_t T;
  //T i;set_i(i); //with inlib::symbol
  T i(0,1);
  T _i = T(-1)*i;
  matrix_set<MAT>(a_m,  0, _i,
                        i, 0);
}
template <class MAT>
inline void set_P3(MAT& a_m) {
  matrix_set<MAT>(a_m, 1, 0,
                       0,-1);
}

template <class VECTOR>
inline void set_paulis(VECTOR& a_paulis) {
  a_paulis.resize(3);
  set_P1(a_paulis[0]);
  set_P2(a_paulis[1]);
  set_P3(a_paulis[2]);
}
////////////////////////////////////////////////
/// D=4 ////////////////////////////////////////
////////////////////////////////////////////////
template <class MAT>
inline void set_J(MAT& a_m) {
  matrix_set(a_m,    0, 0, 0, 1,
                     0, 0,-1, 0,
                     0, 1, 0, 0,
                    -1, 0, 0, 0);
}
template <class MAT>
inline void set_maj_D1_S(MAT& a_m) {
  matrix_set(a_m,    0,-1, 0, 0,
                    -1, 0, 0, 0,
                     0, 0, 0, 1,
                     0, 0, 1, 0);
  a_m.multiply(0.5);
}
template <class MAT>
inline void set_maj_D2_S(MAT& a_m) {
  matrix_set(a_m,    0, 0,-1, 0,
                     0, 0, 0,-1,
                    -1, 0, 0, 0,
                     0,-1, 0, 0);
  a_m.multiply(0.5);
}
template <class MAT>
inline void set_maj_D3_S(MAT& a_m) {
  matrix_set(a_m,   -1, 0, 0, 0,
                     0, 1, 0, 0,
                     0, 0, 1, 0,
                     0, 0, 0,-1);
  a_m.multiply(0.5);
}
template <class MAT>
inline void set_maj_D4_S(MAT& a_m) {
  matrix_set(a_m,    1, 0, 0, 0,
                     0,-1, 0, 0,
                     0, 0, 1, 0,
                     0, 0, 0,-1);
  a_m.multiply(0.5);
}
template <class MAT>
inline void set_maj_D5_S(MAT& a_m) {
  matrix_set(a_m,    0, 0, 0, 1,
                     0, 0,-1, 0,
                     0,-1, 0, 0,
                     1, 0, 0, 0);
  a_m.multiply(0.5);
}
template <class MAT>
inline void set_maj_D6_S(MAT& a_m) {
  matrix_set(a_m,    0,-1, 0, 0,
                    -1, 0, 0, 0,
                     0, 0, 0,-1,
                     0, 0,-1, 0);
  a_m.multiply(0.5);
}
}
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////

#include <inlib/op_func>

#include <inlib/legendre_polynomial>

#include <inlib/real>

#include <inlib/mathz>

namespace inlib {
namespace dirac {

class C_theta : public inlib::op_func<inlib::real> {
  typedef inlib::op_func<inlib::real> parent;
public:
  virtual bool value(const real& a_theta,real& a_v) const {
    bool status = inlib::cos_spherical_harmonic<int,real>(m_m,m_l,a_theta,m_phi,a_v,
          inlib::real_sqrt_const,inlib::real_sin_const,inlib::real_cos_const,inlib::real_pi());
    if(!status) m_out << "C_theta::value problem." << std::endl;
    return status;
  }
public:
  C_theta(std::ostream& a_out,const int& a_l,const int& a_m,const real& a_phi):parent(),m_out(a_out),m_l(a_l),m_m(a_m),m_phi(a_phi){}
  virtual ~C_theta(){}
public:
  C_theta(const C_theta& a_from):parent(a_from),m_out(a_from.m_out),m_l(a_from.m_l),m_m(a_from.m_m),m_phi(a_from.m_phi){}
  C_theta& operator=(const C_theta& a_from){parent::operator=(a_from);m_l=a_from.m_l;m_m=a_from.m_m;m_phi=a_from.m_phi;return *this;}
protected:
  std::ostream& m_out;
  int m_l;
  int m_m;
  real m_phi;
};

class C_phi : public inlib::op_func<inlib::real> {
  typedef inlib::op_func<inlib::real> parent;
public:
  virtual bool value(const real& a_phi,real& a_v) const {
    bool status = inlib::cos_spherical_harmonic<int,real>(m_m,m_l,m_theta,a_phi,a_v,
          inlib::real_sqrt_const,inlib::real_sin_const,inlib::real_cos_const,inlib::real_pi());
    if(!status) m_out << "C_phi::value problem." << std::endl;
    return status;
  }
public:
  C_phi(std::ostream& a_out,const int& a_l,const int& a_m,const real& a_theta):parent(),m_out(a_out),m_l(a_l),m_m(a_m),m_theta(a_theta){}
  virtual ~C_phi(){}
public:
  C_phi(const C_phi& a_from):parent(a_from),m_out(a_from.m_out),m_l(a_from.m_l),m_m(a_from.m_m),m_theta(a_from.m_theta){}
  C_phi& operator=(const C_phi& a_from){parent::operator=(a_from);m_l=a_from.m_l;m_m=a_from.m_m;m_theta=a_from.m_theta;return *this;}
protected:
  std::ostream& m_out;
  int m_l;
  int m_m;
  real m_theta;
};

class S_theta : public inlib::op_func<inlib::real> {
  typedef inlib::op_func<inlib::real> parent;
public:
  virtual bool value(const real& a_theta,real& a_v) const {
    bool status = inlib::sin_spherical_harmonic<int,real>(m_m,m_l,a_theta,m_phi,a_v,
          inlib::real_sqrt_const,inlib::real_sin_const,inlib::real_cos_const,inlib::real_pi());
    if(!status) m_out << "S_theta::value problem." << std::endl;
    return status;
  }
public:
  S_theta(std::ostream& a_out,const int& a_l,const int& a_m,const real& a_phi):parent(),m_out(a_out),m_l(a_l),m_m(a_m),m_phi(a_phi){}
  virtual ~S_theta(){}
public:
  S_theta(const S_theta& a_from):parent(a_from),m_out(a_from.m_out),m_l(a_from.m_l),m_m(a_from.m_m),m_phi(a_from.m_phi){}
  S_theta& operator=(const S_theta& a_from){parent::operator=(a_from);m_l=a_from.m_l;m_m=a_from.m_m;m_phi=a_from.m_phi;return *this;}
protected:
  std::ostream& m_out;
  int m_l;
  int m_m;
  real m_phi;
};

class S_phi : public inlib::op_func<inlib::real> {
  typedef inlib::op_func<inlib::real> parent;
public:
  virtual bool value(const real& a_phi,real& a_v) const {
    bool status = inlib::sin_spherical_harmonic<int,real>(m_m,m_l,m_theta,a_phi,a_v,
          inlib::real_sqrt_const,inlib::real_sin_const,inlib::real_cos_const,inlib::real_pi());
    if(!status) m_out << "S_phi::value problem." << std::endl;
    return status;
  }
public:
  S_phi(std::ostream& a_out,const int& a_l,const int& a_m,const real& a_theta):parent(),m_out(a_out),m_l(a_l),m_m(a_m),m_theta(a_theta){}
  virtual ~S_phi(){}
public:
  S_phi(const S_phi& a_from):parent(a_from),m_out(a_from.m_out),m_l(a_from.m_l),m_m(a_from.m_m),m_theta(a_from.m_theta){}
  S_phi& operator=(const S_phi& a_from){parent::operator=(a_from);m_l=a_from.m_l;m_m=a_from.m_m;m_theta=a_from.m_theta;return *this;}
protected:
  std::ostream& m_out;
  int m_l;
  int m_m;
  real m_theta;
};

}}

inline inlib::real sqrt_l_m_1(int a_l,int a_m) {return inlib::real_sqrt_const(a_l+a_m+1);}
inline inlib::real sqrt_l_m(int a_l,int a_m) {return inlib::real_sqrt_const(a_l-a_m);}

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
#include <inlib/test>

inline bool check_dirac_angular_minus(std::ostream& a_out,int a_l,int a_m,const inlib::real& a_theta,const inlib::real& a_phi,bool a_verbose) {

  if(a_verbose) a_out << "check_dirac_angular_minus:" << std::endl;

  if(a_verbose) a_out << "l " << a_l << ", m " << a_m << std::endl;
  if(a_verbose) a_out << "theta " << a_theta*inlib::real_rad2deg() << ", phi " << a_phi*inlib::real_rad2deg() << std::endl;

  if(a_l<0) {a_out << "l < 0." << std::endl;return false;}
  if(::fabs(a_m)>=a_l) {a_out << "m >= l." << std::endl;return false;}

  if(a_theta<inlib::real_zero()) {a_out << "theta < 0." << std::endl;return false;}
  if(inlib::real_pi()<a_theta) {a_out << "pi < theta." << std::endl;return false;}

  if(a_phi<inlib::real_zero()) {a_out << "phi < 0." << std::endl;return false;}
  if(inlib::real_two_pi()<=a_phi) {a_out << "2*pi <= phi." << std::endl;return false;}

  inlib::real value;

  //_C_l_m_plus_1 =  sqrt_l_m_1(l,m) * CosY(l,m+1,a_theta,a_phi):
  //_C_l_m        =  sqrt_l_m(l,m)   * CosY(l,  m,a_theta,a_phi):
  //_S_l_m        =  sqrt_l_m(l,m)   * SinY(l,  m,a_theta,a_phi):
  //_S_l_m_plus_1 =  sqrt_l_m_1(l,m) * SinY(l,m+1,a_theta,a_phi):

  inlib::dirac::C_theta C_l_m_plus_1_theta(a_out,a_l,a_m+1,a_phi);
  if(!C_l_m_plus_1_theta.value(a_theta,value)) return false;
  if(a_verbose) a_out << "C l m+1 : " << value << std::endl;
  inlib::real _C_l_m_plus_1 = sqrt_l_m_1(a_l,a_m)*value;

  inlib::dirac::C_theta C_l_m_theta(a_out,a_l,a_m,a_phi);
  if(!C_l_m_theta.value(a_theta,value)) return false;
  if(a_verbose) a_out << "C l m : " << value << std::endl;
  inlib::real _C_l_m = sqrt_l_m(a_l,a_m)*value;

  inlib::dirac::S_theta S_l_m_theta(a_out,a_l,a_m,a_phi);
  if(!S_l_m_theta.value(a_theta,value)) return false;
  if(a_verbose) a_out << "S l m : " << value << std::endl;
  inlib::real _S_l_m =  sqrt_l_m(a_l,a_m)*value;

  inlib::dirac::S_theta S_l_m_plus_1_theta(a_out,a_l,a_m+1,a_phi);
  if(!S_l_m_plus_1_theta.value(a_theta,value)) return false;
  if(a_verbose) a_out << "S l m+1 : " << value << std::endl;
  inlib::real _S_l_m_plus_1 = sqrt_l_m_1(a_l,a_m)*value;

  inlib::real dxepsil(1e-3);
  inlib::real dxfactor(0.5);
  unsigned int dxiters = 4;  //=> dxepsil*(dxfactor**dxiters)

  //_C_l_m_plus_1 =  sqrt_l_m_1(l,m) * CosY(l,m+1,a_theta,a_phi):
  //_C_l_m =  sqrt_l_m(l,m)   * CosY(l,  m,a_theta,a_phi):
  //_S_l_m =  sqrt_l_m(l,m)   * SinY(l,  m,a_theta,a_phi):
  //_S_l_m_plus_1 = sqrt_l_m_1(l,m) * SinY(l,m+1,a_theta,a_phi):
  inlib::op_derivative<unsigned int,inlib::real>
    d_C_l_m_plus_1_theta(a_out,C_l_m_plus_1_theta,dxepsil,dxfactor,dxiters,
                         inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_C_l_m_plus_1_theta.value(a_theta,value)) return false;
  if(a_verbose) a_out << "C l m+1 theta : " << value << std::endl;
  inlib::real _C_l_m_plus_1_theta = sqrt_l_m_1(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_C_l_m_theta(a_out,C_l_m_theta,dxepsil,dxfactor,dxiters,
                  inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_C_l_m_theta.value(a_theta,value)) return false;
  if(a_verbose) a_out << "C l m theta : " << value << std::endl;
  inlib::real _C_l_m_theta = sqrt_l_m(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_S_l_m_theta(a_out,S_l_m_theta,dxepsil,dxfactor,dxiters,
                  inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_S_l_m_theta.value(a_theta,value)) return false;
  if(a_verbose) a_out << "S l m theta : " << value << std::endl;
  inlib::real _S_l_m_theta = sqrt_l_m(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_S_l_m_plus_1_theta(a_out,S_l_m_plus_1_theta,dxepsil,dxfactor,dxiters,
                         inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_S_l_m_plus_1_theta.value(a_theta,value)) return false;
  if(a_verbose) a_out << "S l m+1 theta : " << value << std::endl;
  inlib::real _S_l_m_plus_1_theta = sqrt_l_m_1(a_l,a_m)*value;

  inlib::dirac::C_phi C_l_m_plus_1_phi(a_out,a_l,a_m+1,a_theta);
  inlib::dirac::C_phi C_l_m_phi(a_out,a_l,a_m,a_theta);
  inlib::dirac::S_phi S_l_m_phi(a_out,a_l,a_m,a_theta);
  inlib::dirac::S_phi S_l_m_plus_1_phi(a_out,a_l,a_m+1,a_theta);

  inlib::op_derivative<unsigned int,inlib::real>
    d_C_l_m_plus_1_phi(a_out,C_l_m_plus_1_phi,dxepsil,dxfactor,dxiters,
                       inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_C_l_m_plus_1_phi.value(a_phi,value)) return false;
  if(a_verbose) a_out << "C l m+1 phi : " << value << std::endl;
  inlib::real _C_l_m_plus_1_phi = sqrt_l_m_1(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_C_l_m_phi(a_out,C_l_m_phi,dxepsil,dxfactor,dxiters,
                inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_C_l_m_phi.value(a_phi,value)) return false;
  if(a_verbose) a_out << "C l m phi : " << value << std::endl;
  inlib::real _C_l_m_phi = sqrt_l_m(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_S_l_m_phi(a_out,S_l_m_phi,dxepsil,dxfactor,dxiters,
                inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_S_l_m_phi.value(a_phi,value)) return false;
  if(a_verbose) a_out << "S l m phi : " << value << std::endl;
  inlib::real _S_l_m_phi = sqrt_l_m(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_S_l_m_plus_1_phi(a_out,S_l_m_plus_1_phi,dxepsil,dxfactor,dxiters,
                       inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_S_l_m_plus_1_phi.value(a_phi,value)) return false;
  if(a_verbose) a_out << "S l m+1 phi : " << value << std::endl;
  inlib::real _S_l_m_plus_1_phi = sqrt_l_m_1(a_l,a_m)*value;

  inlib::real cot_theta = inlib::real_cos(a_theta)/inlib::real_sin(a_theta);
  inlib::real sin_phi = inlib::real_sin(a_phi);
  inlib::real cos_phi = inlib::real_cos(a_phi);

  inlib::real depsilon = 1e-2;

  /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////
 {typedef inlib::mat<inlib::real,4> m4d;
  std::vector<m4d> maj_DSs(6); //6
  inlib::set_maj_D1_S(maj_DSs[0]);
  inlib::set_maj_D2_S(maj_DSs[1]);
  inlib::set_maj_D3_S(maj_DSs[2]);
  inlib::set_maj_D4_S(maj_DSs[3]);
  inlib::set_maj_D5_S(maj_DSs[4]);
  inlib::set_maj_D6_S(maj_DSs[5]);

  m4d J;set_J(J);
  std::vector<m4d> maj_DSs_J(maj_DSs);  //6
  inlib::multiply(maj_DSs_J,J);

  m4d left_phi = inlib::real(2)*(maj_DSs_J[2]-cot_theta*sin_phi*maj_DSs_J[1]-cot_theta*cos_phi*maj_DSs_J[0]);
  m4d left_theta = inlib::real(2)*(cos_phi*maj_DSs_J[1]-sin_phi*maj_DSs_J[0]);

  std::vector<inlib::real> Zs;
  Zs.push_back(-_C_l_m_plus_1);
  Zs.push_back(-_C_l_m);
  Zs.push_back(_S_l_m);
  Zs.push_back(-_S_l_m_plus_1);

  std::vector<inlib::real> Z_thetas;
  Z_thetas.push_back(-_C_l_m_plus_1_theta);
  Z_thetas.push_back(-_C_l_m_theta);
  Z_thetas.push_back(_S_l_m_theta);
  Z_thetas.push_back(-_S_l_m_plus_1_theta);

  std::vector<inlib::real> Z_phis;
  Z_phis.push_back(-_C_l_m_plus_1_phi);
  Z_phis.push_back(-_C_l_m_phi);
  Z_phis.push_back(_S_l_m_phi);
  Z_phis.push_back(-_S_l_m_plus_1_phi);

 {for(size_t alpha=0;alpha<4;alpha++) {
    inlib::real left(0);
    for(size_t beta=0;beta<4;beta++) {
      left += left_phi.value(alpha,beta)*Z_phis[beta];
      left += left_theta.value(alpha,beta)*Z_thetas[beta];
    }
    inlib::real right = -(a_l+1)*Zs[alpha];
    if(!inlib::numbers_are_equal(left,right,depsilon,inlib::real_fabs_const)) {
      a_out << "check_minus real problem:" << std::endl;
      a_out << "l " << a_l << ", m " << a_m << std::endl;
      a_out << "theta " << a_theta*inlib::real_rad2deg() << ", phi " << a_phi*inlib::real_rad2deg() << std::endl;
      a_out << "alpha " << alpha << " " << left << " != " << right  << std::endl;
      return false;
    }
  }}

  }

  /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////
 {typedef std::complex<inlib::real> z;
  typedef inlib::mat<z,2> m2z;
  std::vector<m2z> paulis;inlib::set_paulis(paulis);

  z zi(0,1);

  m2z left_phi =
    zi*(z(-1)*paulis[2]+z(cot_theta*sin_phi)*paulis[1]+z(cot_theta*cos_phi)*paulis[0]);
  m2z left_theta = zi*(z(-cos_phi)*paulis[1]+z(sin_phi)*paulis[0]);

  std::vector<z> Zs;
  Zs.push_back(z(-1)*(_C_l_m+zi*_S_l_m));
  Zs.push_back(_C_l_m_plus_1+zi*_S_l_m_plus_1);

  std::vector<z> Z_thetas;
  Z_thetas.push_back(z(-1)*(_C_l_m_theta+zi*_S_l_m_theta));
  Z_thetas.push_back(_C_l_m_plus_1_theta+zi*_S_l_m_plus_1_theta);

  std::vector<z> Z_phis;
  Z_phis.push_back(z(-1)*(_C_l_m_phi+zi*_S_l_m_phi));
  Z_phis.push_back(_C_l_m_plus_1_phi+zi*_S_l_m_plus_1_phi);

 {for(size_t alpha=0;alpha<2;alpha++) {
    z left(0);
    for(size_t beta=0;beta<2;beta++) {
      left += left_phi.value(alpha,beta)*Z_phis[beta];
      left += left_theta.value(alpha,beta)*Z_thetas[beta];
    }
    z right = z(-(a_l+1))*Zs[alpha];
    if(!inlib::numbers_are_equal(left,right,depsilon,inlib::z_abs)) {
      a_out << "check_minus complex problem:" << std::endl;
      a_out << "l " << a_l << ", m " << a_m << std::endl;
      a_out << "theta " << a_theta*inlib::real_rad2deg() << ", phi " << a_phi*inlib::real_rad2deg() << std::endl;
      a_out << "alpha " << alpha << " " << left << " != " << right  << std::endl;
      return false;
    }
  }}

  }
  
  return true;
}

inline bool check_dirac_angular_plus(std::ostream& a_out,int a_l,int a_m,const inlib::real& a_theta,const inlib::real& a_phi,bool a_verbose) {

  if(a_verbose) a_out << "check_dirac_angular_plus:" << std::endl;

  if(a_verbose) a_out << "l " << a_l << ", m " << a_m << std::endl;
  if(a_verbose) a_out << "theta " << a_theta*inlib::real_rad2deg() << ", phi " << a_phi*inlib::real_rad2deg() << std::endl;

  if(a_l<0) {a_out << "l < 0." << std::endl;return false;}
  if(::fabs(a_m)>=a_l) {a_out << "m >= l." << std::endl;return false;}

  if(a_theta<inlib::real_zero()) {a_out << "theta < 0." << std::endl;return false;}
  if(inlib::real_pi()<a_theta) {a_out << "pi < theta." << std::endl;return false;}

  if(a_phi<inlib::real_zero()) {a_out << "phi < 0." << std::endl;return false;}
  if(inlib::real_two_pi()<=a_phi) {a_out << "2*pi <= phi." << std::endl;return false;}

  inlib::real value;

  //_C_l_m_plus_1 =  sqrt_l_m(l,m)   * CosY(l,m+1,a_theta,a_phi):
  //_C_l_m        =  sqrt_l_m_1(l,m) * CosY(l,  m,a_theta,a_phi):
  //_S_l_m        =  sqrt_l_m_1(l,m) * SinY(l,  m,a_theta,a_phi):
  //_S_l_m_plus_1 =  sqrt_l_m(l,m)   * SinY(l,m+1,a_theta,a_phi):

  inlib::dirac::C_theta C_l_m_plus_1_theta(a_out,a_l,a_m+1,a_phi);
  if(!C_l_m_plus_1_theta.value(a_theta,value)) {a_out << "C l m+1 failed." << std::endl;return false;}
  if(a_verbose) a_out << "C l m+1 : " << value << std::endl;
  inlib::real _C_l_m_plus_1 = sqrt_l_m(a_l,a_m)*value;

  inlib::dirac::C_theta C_l_m_theta(a_out,a_l,a_m,a_phi);
  if(!C_l_m_theta.value(a_theta,value)) {a_out << "C l m failed." << std::endl;return false;}
  if(a_verbose) a_out << "C l m : " << value << std::endl;
  inlib::real _C_l_m = sqrt_l_m_1(a_l,a_m)*value;

  inlib::dirac::S_theta S_l_m_theta(a_out,a_l,a_m,a_phi);
  if(!S_l_m_theta.value(a_theta,value)) {a_out << "S l m failed." << std::endl;return false;}
  if(a_verbose) a_out << "S l m : " << value << std::endl;
  inlib::real _S_l_m =  sqrt_l_m_1(a_l,a_m)*value;

  inlib::dirac::S_theta S_l_m_plus_1_theta(a_out,a_l,a_m+1,a_phi);
  if(!S_l_m_plus_1_theta.value(a_theta,value)) {a_out << "S l m failed." << std::endl;return false;}
  if(a_verbose) a_out << "S l m+1 : " << value << std::endl;
  inlib::real _S_l_m_plus_1 = sqrt_l_m(a_l,a_m)*value;

  inlib::real dxepsil(1e-3);
  inlib::real dxfactor(0.5);
  unsigned int dxiters = 4;  //=> dxepsil*(dxfactor**dxiters)

  inlib::op_derivative<unsigned int,inlib::real>
    d_C_l_m_plus_1_theta(a_out,C_l_m_plus_1_theta,dxepsil,dxfactor,dxiters,
                         inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_C_l_m_plus_1_theta.value(a_theta,value)) {a_out << "d_theta C l m+1 failed." << std::endl;return false;}
  if(a_verbose) a_out << "C l m+1 theta : " << value << std::endl;
  inlib::real _C_l_m_plus_1_theta = sqrt_l_m(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_C_l_m_theta(a_out,C_l_m_theta,dxepsil,dxfactor,dxiters,
                  inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_C_l_m_theta.value(a_theta,value)){a_out << "d_theta C l m failed." << std::endl;return false;}
  if(a_verbose) a_out << "C l m theta : " << value << std::endl;
  inlib::real _C_l_m_theta = sqrt_l_m_1(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_S_l_m_theta(a_out,S_l_m_theta,dxepsil,dxfactor,dxiters,
                  inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_S_l_m_theta.value(a_theta,value)) {a_out << "d_theta S l m failed." << std::endl;return false;}
  if(a_verbose) a_out << "S l m theta : " << value << std::endl;
  inlib::real _S_l_m_theta = sqrt_l_m_1(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_S_l_m_plus_1_theta(a_out,S_l_m_plus_1_theta,dxepsil,dxfactor,dxiters,
                         inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_S_l_m_plus_1_theta.value(a_theta,value)) {a_out << "d_theta S l m+1 failed." << std::endl;return false;}
  if(a_verbose) a_out << "S l m+1 theta : " << value << std::endl;
  inlib::real _S_l_m_plus_1_theta = sqrt_l_m(a_l,a_m)*value;

  inlib::dirac::C_phi C_l_m_plus_1_phi(a_out,a_l,a_m+1,a_theta);
  inlib::dirac::C_phi C_l_m_phi(a_out,a_l,a_m,a_theta);
  inlib::dirac::S_phi S_l_m_phi(a_out,a_l,a_m,a_theta);
  inlib::dirac::S_phi S_l_m_plus_1_phi(a_out,a_l,a_m+1,a_theta);

  inlib::op_derivative<unsigned int,inlib::real>
    d_C_l_m_plus_1_phi(a_out,C_l_m_plus_1_phi,dxepsil,dxfactor,dxiters,
                       inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_C_l_m_plus_1_phi.value(a_phi,value)) {a_out << "d_phi C l m+1 failed." << std::endl;return false;}
  if(a_verbose) a_out << "C l m+1 phi : " << value << std::endl;
  inlib::real _C_l_m_plus_1_phi = sqrt_l_m(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_C_l_m_phi(a_out,C_l_m_phi,dxepsil,dxfactor,dxiters,
                inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_C_l_m_phi.value(a_phi,value)) {a_out << "d_phi C l m failed." << std::endl;return false;}
  if(a_verbose) a_out << "C l m phi : " << value << std::endl;
  inlib::real _C_l_m_phi = sqrt_l_m_1(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_S_l_m_phi(a_out,S_l_m_phi,dxepsil,dxfactor,dxiters,
                inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_S_l_m_phi.value(a_phi,value)) {a_out << "d_phi S l m failed." << std::endl;return false;}
  if(a_verbose) a_out << "S l m phi : " << value << std::endl;
  inlib::real _S_l_m_phi = sqrt_l_m_1(a_l,a_m)*value;

  inlib::op_derivative<unsigned int,inlib::real>
    d_S_l_m_plus_1_phi(a_out,S_l_m_plus_1_phi,dxepsil,dxfactor,dxiters,
                       inlib::real_set_prec_from,inlib::real_fabs_const);
  if(!d_S_l_m_plus_1_phi.value(a_phi,value)) {a_out << "d_phi S l m+1 failed." << std::endl;return false;}
  if(a_verbose) a_out << "S l m+1 phi : " << value << std::endl;
  inlib::real _S_l_m_plus_1_phi = sqrt_l_m(a_l,a_m)*value;

  inlib::real cot_theta = inlib::real_cos(a_theta)/inlib::real_sin(a_theta);
  inlib::real sin_phi = inlib::real_sin(a_phi);
  inlib::real cos_phi = inlib::real_cos(a_phi);

  inlib::real depsilon = 1e-2;

  /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////
 {typedef inlib::mat<inlib::real,4> m4d;
  std::vector<m4d> maj_DSs(6); //6
  inlib::set_maj_D1_S(maj_DSs[0]);
  inlib::set_maj_D2_S(maj_DSs[1]);
  inlib::set_maj_D3_S(maj_DSs[2]);
  inlib::set_maj_D4_S(maj_DSs[3]);
  inlib::set_maj_D5_S(maj_DSs[4]);
  inlib::set_maj_D6_S(maj_DSs[5]);

  m4d J;set_J(J);
  std::vector<m4d> maj_DSs_J(maj_DSs);  //6
  inlib::multiply(maj_DSs_J,J);

  m4d left_phi = inlib::real(2)*(maj_DSs_J[2]-cot_theta*sin_phi*maj_DSs_J[1]-cot_theta*cos_phi*maj_DSs_J[0]);
  m4d left_theta = inlib::real(2)*(cos_phi*maj_DSs_J[1]-sin_phi*maj_DSs_J[0]);

  std::vector<inlib::real> Zs;
  Zs.push_back(-_C_l_m_plus_1);
  Zs.push_back(_C_l_m);
  Zs.push_back(-_S_l_m);
  Zs.push_back(-_S_l_m_plus_1);

  std::vector<inlib::real> Z_thetas;
  Z_thetas.push_back(-_C_l_m_plus_1_theta);
  Z_thetas.push_back(_C_l_m_theta);
  Z_thetas.push_back(-_S_l_m_theta);
  Z_thetas.push_back(-_S_l_m_plus_1_theta);

  std::vector<inlib::real> Z_phis;
  Z_phis.push_back(-_C_l_m_plus_1_phi);
  Z_phis.push_back(_C_l_m_phi);
  Z_phis.push_back(-_S_l_m_phi);
  Z_phis.push_back(-_S_l_m_plus_1_phi);

 {for(size_t alpha=0;alpha<4;alpha++) {
    inlib::real left(0);
    for(size_t beta=0;beta<4;beta++) {
      left += left_phi.value(alpha,beta)*Z_phis[beta];
      left += left_theta.value(alpha,beta)*Z_thetas[beta];
    }
    inlib::real right = a_l*Zs[alpha];
    if(!inlib::numbers_are_equal(left,right,depsilon,inlib::real_fabs_const)) {
      a_out << "check_plus real problem:" << std::endl;
      a_out << "l " << a_l << ", m " << a_m << std::endl;
      a_out << "theta " << a_theta*inlib::real_rad2deg() << ", phi " << a_phi*inlib::real_rad2deg() << std::endl;
      a_out << "alpha " << alpha << " " << left << " != " << right  << std::endl;
      return false;
    }
  }}

  }

  /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////
 {typedef std::complex<inlib::real> z;
  typedef inlib::mat<z,2> m2z;
  std::vector<m2z> paulis;inlib::set_paulis(paulis);

  z zi(0,1);

  m2z left_phi =
    zi*(z(-1)*paulis[2]+z(cot_theta*sin_phi)*paulis[1]+z(cot_theta*cos_phi)*paulis[0]);
  m2z left_theta = zi*(z(-cos_phi)*paulis[1]+z(sin_phi)*paulis[0]);

  std::vector<z> Zs;
  Zs.push_back(_C_l_m+zi*_S_l_m);
  Zs.push_back(_C_l_m_plus_1+zi*_S_l_m_plus_1);

  std::vector<z> Z_thetas;
  Z_thetas.push_back(_C_l_m_theta+zi*_S_l_m_theta);
  Z_thetas.push_back(_C_l_m_plus_1_theta+zi*_S_l_m_plus_1_theta);

  std::vector<z> Z_phis;
  Z_phis.push_back(_C_l_m_phi+zi*_S_l_m_phi);
  Z_phis.push_back(_C_l_m_plus_1_phi+zi*_S_l_m_plus_1_phi);

 {for(size_t alpha=0;alpha<2;alpha++) {
    z left(0);
    for(size_t beta=0;beta<2;beta++) {
      left += left_phi.value(alpha,beta)*Z_phis[beta];
      left += left_theta.value(alpha,beta)*Z_thetas[beta];
    }
    z right = z(a_l)*Zs[alpha];
    if(!inlib::numbers_are_equal(left,right,depsilon,inlib::z_abs)) {
      a_out << "check_plus complex problem:" << std::endl;
      a_out << "l " << a_l << ", m " << a_m << std::endl;
      a_out << "theta " << a_theta*inlib::real_rad2deg() << ", phi " << a_phi*inlib::real_rad2deg() << std::endl;
      a_out << "alpha " << alpha << " " << left << " != " << right  << std::endl;
      return false;
    }
  }}

  }
  
  return true;
}

inline bool check_dirac_angular(std::ostream& a_out,bool a_verbose) {
  inlib::real dtheta(10); //degree.
  inlib::real dphi = dtheta;

  //NOTE: problems with theta=pi.

//for(inlib::real theta=inlib::real(0);theta<=inlib::real(180);theta+=dtheta) {
  for(inlib::real theta=inlib::real(0);theta<inlib::real(180);theta+=dtheta) {
  for(inlib::real phi=inlib::real(0);phi<inlib::real(360);phi+=dphi) {

  for(int l=0;l<=5;l++) {
  for(int m=-(l-1);m<=(l-1);m++) {
    if(!check_dirac_angular_minus
        (a_out,l,m,theta*inlib::real_deg2rad(),phi*inlib::real_deg2rad(),a_verbose)) {return false;}
    if(!check_dirac_angular_plus
        (a_out,l,m,theta*inlib::real_deg2rad(),phi*inlib::real_deg2rad(),a_verbose)) {return false;}
  }}

  }}

  return true;
}

#endif
